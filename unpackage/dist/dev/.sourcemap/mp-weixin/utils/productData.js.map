{"version":3,"file":"productData.js","sources":["utils/productData.js"],"sourcesContent":["// 产品数据管理\nimport { fetchCategories, fetchCategoryById } from \"./api/categoryApi\";\nimport { fetchProductsByCategory } from \"./api/productApi\";\nimport { getDefaultProductData } from \"./productService\";\n\n// 从API获取产品和分类数据\nconst fetchProductDataFromAPI = async () => {\n  try {\n    // 1. 获取所有分类\n    const categories = await fetchCategories();\n\n    // 2. 对每个分类获取对应的产品\n    const result = await Promise.all(\n      categories.map(async (category) => {\n        // 获取该分类下的产品\n        const products = await fetchProductsByCategory(category.id);\n\n        // 转换为前端需要的格式，确保字段映射正确\n        return {\n          name: category.name,\n          products: products.map((product) => {\n            // 统一字段名称，确保兼容性\n            return {\n              id: product.id,\n              image: product.imageUrl || `/static/images/default-product.png`,\n              imageUrl:\n                product.imageUrl || `/static/images/default-product.png`, // 同时保留两个字段\n              name: product.name || \"\",\n              desc: product.description || \"\", // 确保desc和description都有值\n              description: product.description || \"\",\n              price: product.price || 0,\n              category: category.name,\n              // 保留其他可能的原始字段\n              ...product,\n            };\n          }),\n        };\n      })\n    );\n\n    return result;\n  } catch (error) {\n    throw error;\n  }\n};\n\n// 获取产品数据 - 直接从API获取，如果失败则使用默认数据\nexport const getProductData = async () => {\n  try {\n    // 直接从API获取\n    const apiData = await fetchProductDataFromAPI();\n    return apiData;\n  } catch (e) {\n    // 如果API失败，返回默认数据\n    return getDefaultProductData();\n  }\n};\n\n// 刷新产品数据（从API获取）\nexport const refreshProductData = async () => {\n  try {\n    // 从API获取\n    const apiData = await fetchProductDataFromAPI();\n    return apiData;\n  } catch (e) {\n    // 如果API获取失败，返回默认数据\n    return getDefaultProductData();\n  }\n};\n\n// 更新特定产品信息\nexport const updateProduct = async (\n  categoryIndex,\n  productIndex,\n  updatedProduct\n) => {\n  try {\n    const allProducts = await getProductData();\n\n    // 确保索引有效\n    if (\n      categoryIndex >= 0 &&\n      categoryIndex < allProducts.length &&\n      productIndex >= 0 &&\n      productIndex < allProducts[categoryIndex].products.length\n    ) {\n      // 更新产品\n      allProducts[categoryIndex].products[productIndex] = {\n        ...allProducts[categoryIndex].products[productIndex],\n        ...updatedProduct,\n      };\n\n      // 这里可以添加API调用来同步更新到后端\n\n      return true;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n\n// 添加新产品到指定分类\nexport const addProduct = async (categoryIndex, newProduct) => {\n  try {\n    const allProducts = await getProductData();\n\n    // 确保分类索引有效\n    if (categoryIndex >= 0 && categoryIndex < allProducts.length) {\n      // 添加新产品\n      allProducts[categoryIndex].products.push(newProduct);\n\n      // 这里可以添加API调用来同步更新到后端\n\n      return true;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n\n// 删除产品\nexport const deleteProduct = async (categoryIndex, productIndex) => {\n  try {\n    const allProducts = await getProductData();\n\n    // 确保索引有效\n    if (\n      categoryIndex >= 0 &&\n      categoryIndex < allProducts.length &&\n      productIndex >= 0 &&\n      productIndex < allProducts[categoryIndex].products.length\n    ) {\n      // 删除产品\n      allProducts[categoryIndex].products.splice(productIndex, 1);\n\n      // 这里可以添加API调用来同步更新到后端\n\n      return true;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n\n// 添加新分类\nexport const addCategory = async (newCategory) => {\n  try {\n    const allProducts = await getProductData();\n\n    // 添加新分类\n    allProducts.push({\n      name: newCategory.name,\n      products: newCategory.products || [],\n    });\n\n    // 这里可以添加API调用来同步更新到后端\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n// 删除分类\nexport const deleteCategory = async (categoryIndex) => {\n  try {\n    const allProducts = await getProductData();\n\n    // 确保索引有效\n    if (categoryIndex >= 0 && categoryIndex < allProducts.length) {\n      // 删除分类\n      allProducts.splice(categoryIndex, 1);\n\n      // 这里可以添加API调用来同步更新到后端\n\n      return true;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n\n// 搜索产品\nexport const searchProducts = async (keyword) => {\n  try {\n    if (!keyword) return [];\n\n    const allProducts = await getProductData();\n    const result = [];\n\n    // 转换关键词为小写以进行不区分大小写的搜索\n    const lowerKeyword = keyword.toLowerCase();\n\n    // 遍历所有分类和产品\n    allProducts.forEach((category) => {\n      category.products.forEach((product) => {\n        // 检查产品名称或描述是否包含关键词\n        const nameMatch =\n          product.name && product.name.toLowerCase().includes(lowerKeyword);\n\n        // 检查description字段(后端API)或desc字段(本地数据)\n        const descMatch =\n          (product.description &&\n            product.description.toLowerCase().includes(lowerKeyword)) ||\n          (product.desc && product.desc.toLowerCase().includes(lowerKeyword));\n\n        if (nameMatch || descMatch) {\n          result.push({\n            ...product,\n            category: category.name,\n          });\n        }\n      });\n    });\n\n    return result;\n  } catch (e) {\n    return [];\n  }\n};\n\n// 高级搜索产品\nexport const advancedSearchProducts = async (options = {}) => {\n  try {\n    const {\n      keyword = \"\",\n      minPrice = 0,\n      maxPrice = Infinity,\n      categoryNames = [],\n      sortBy = \"price\", // 'price', 'name'\n      sortOrder = \"asc\", // 'asc', 'desc'\n      limit = 0, // 限制返回结果数量，0表示不限制\n    } = options;\n\n    // 获取所有产品数据\n    const allProducts = await getProductData();\n    let result = [];\n\n    // 转换关键词为小写以进行不区分大小写的搜索\n    const lowerKeyword = keyword.toLowerCase();\n\n    // 遍历所有分类和产品\n    allProducts.forEach((category) => {\n      // 检查是否需要按分类筛选\n      if (categoryNames.length > 0 && !categoryNames.includes(category.name)) {\n        return; // 跳过不在指定分类中的产品\n      }\n\n      category.products.forEach((product) => {\n        // 关键词过滤 - 检查产品名称或描述是否包含关键词\n        const matchesKeyword =\n          !keyword ||\n          product.name.toLowerCase().includes(lowerKeyword) ||\n          product.desc.toLowerCase().includes(lowerKeyword);\n\n        // 价格范围过滤\n        const matchesPrice =\n          product.price >= minPrice && product.price <= maxPrice;\n\n        // 如果满足所有筛选条件，添加到结果中\n        if (matchesKeyword && matchesPrice) {\n          result.push({\n            ...product,\n            category: category.name,\n          });\n        }\n      });\n    });\n\n    // 根据指定字段排序\n    result.sort((a, b) => {\n      if (sortBy === \"name\") {\n        return sortOrder === \"asc\"\n          ? a.name.localeCompare(b.name)\n          : b.name.localeCompare(a.name);\n      } else if (sortBy === \"price\") {\n        return sortOrder === \"asc\" ? a.price - b.price : b.price - a.price;\n      }\n      return 0;\n    });\n\n    // 限制结果数量\n    if (limit > 0 && result.length > limit) {\n      result = result.slice(0, limit);\n    }\n\n    return result;\n  } catch (e) {\n    return [];\n  }\n};\n\n// 获取热门产品（根据固定规则或推荐算法）\nexport const getHotProducts = async (limit = 6) => {\n  try {\n    // 在真实应用中，这里可能会调用专门的API获取热门产品\n    // 这里使用简单的模拟实现，取价格较高的前几个产品作为\"热门\"\n    const allProducts = await getProductData();\n    const hotProducts = [];\n\n    // 收集所有产品\n    allProducts.forEach((category) => {\n      category.products.forEach((product) => {\n        hotProducts.push({\n          ...product,\n          category: category.name,\n        });\n      });\n    });\n\n    // 按价格降序排序并限制数量\n    return hotProducts.sort((a, b) => b.price - a.price).slice(0, limit);\n  } catch (e) {\n    return [];\n  }\n};\n\n// 获取推荐产品（基于分类）\nexport const getRecommendedProducts = async (categoryName, limit = 4) => {\n  try {\n    const allProducts = await getProductData();\n    const recommendedProducts = [];\n\n    // 查找指定分类\n    const targetCategory = allProducts.find(\n      (category) => category.name === categoryName\n    );\n\n    if (targetCategory && targetCategory.products.length > 0) {\n      // 从目标分类中随机选择几个产品\n      const shuffled = [...targetCategory.products].sort(\n        () => 0.5 - Math.random()\n      );\n      const selected = shuffled.slice(0, Math.min(limit, shuffled.length));\n\n      selected.forEach((product) => {\n        recommendedProducts.push({\n          ...product,\n          category: categoryName,\n        });\n      });\n    }\n\n    // 如果推荐产品不足，从其他分类中补充\n    if (recommendedProducts.length < limit) {\n      const neededProducts = limit - recommendedProducts.length;\n      const otherProducts = [];\n\n      allProducts.forEach((category) => {\n        if (category.name !== categoryName) {\n          category.products.forEach((product) => {\n            otherProducts.push({\n              ...product,\n              category: category.name,\n            });\n          });\n        }\n      });\n\n      // 随机打乱并选择所需数量的产品\n      const shuffled = otherProducts.sort(() => 0.5 - Math.random());\n      const selected = shuffled.slice(\n        0,\n        Math.min(neededProducts, shuffled.length)\n      );\n\n      recommendedProducts.push(...selected);\n    }\n\n    return recommendedProducts;\n  } catch (e) {\n    return [];\n  }\n};\n\n// 初始化产品数据 - 用于应用启动时\nexport const initProductData = async () => {\n  try {\n    return await refreshProductData();\n  } catch (e) {\n    return getDefaultProductData();\n  }\n};\n\n/**\n * 获取单个分类下的产品\n * @param {Number} categoryId 分类ID\n * @returns {Promise<Object>} 包含分类和产品的对象\n */\nexport const getCategoryProducts = async (categoryId) => {\n  try {\n    // 1. 获取分类信息\n    const category = await fetchCategoryById(categoryId);\n    if (!category) {\n      throw new Error(\"分类不存在\");\n    }\n\n    // 2. 获取该分类下的产品\n    const products = await fetchProductsByCategory(categoryId);\n\n    // 3. 转换为前端需要的格式\n    return {\n      name: category.name,\n      products: products.map((product) => ({\n        id: product.id,\n        image: product.imageUrl || `/static/images/default-product.png`,\n        name: product.name,\n        desc: product.description,\n        price: product.price,\n      })),\n    };\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * 分页获取产品\n * @param {Object} options 分页选项\n * @returns {Promise<Object>} 分页结果\n */\nexport const getProductsWithPagination = async (options = {}) => {\n  try {\n    const {\n      page = 1,\n      pageSize = 10,\n      keyword = \"\",\n      categoryName = \"\",\n      minPrice = 0,\n      maxPrice = Infinity,\n      sortBy = \"price\",\n      sortOrder = \"asc\",\n    } = options;\n\n    // 获取所有满足筛选条件的产品\n    const filterOptions = {\n      keyword,\n      minPrice,\n      maxPrice,\n      categoryNames: categoryName ? [categoryName] : [],\n      sortBy,\n      sortOrder,\n    };\n\n    // 使用高级搜索获取所有符合条件的产品\n    const allFilteredProducts = await advancedSearchProducts(filterOptions);\n\n    // 计算总数和总页数\n    const total = allFilteredProducts.length;\n    const totalPages = Math.ceil(total / pageSize);\n\n    // 计算当前页的数据\n    const startIndex = (page - 1) * pageSize;\n    const endIndex = Math.min(startIndex + pageSize, total);\n    const currentPageData = allFilteredProducts.slice(startIndex, endIndex);\n\n    return {\n      data: currentPageData,\n      pagination: {\n        total,\n        page,\n        pageSize,\n        totalPages,\n        hasNextPage: page < totalPages,\n        hasPreviousPage: page > 1,\n      },\n    };\n  } catch (e) {\n    return {\n      data: [],\n      pagination: {\n        total: 0,\n        page: options.page || 1,\n        pageSize: options.pageSize || 10,\n        totalPages: 0,\n        hasNextPage: false,\n        hasPreviousPage: false,\n      },\n      error: e.message,\n    };\n  }\n};\n\n/**\n * 获取各分类产品数量\n * @returns {Promise<Array>} 分类统计数据\n */\nexport const getCategoriesStats = async () => {\n  try {\n    const allProducts = await getProductData();\n\n    // 计算每个分类的产品数量和最大/最小价格\n    return allProducts.map((category) => {\n      const productCount = category.products.length;\n\n      // 计算价格范围\n      let minPrice = Infinity;\n      let maxPrice = 0;\n      let totalPrice = 0;\n\n      category.products.forEach((product) => {\n        minPrice = Math.min(minPrice, product.price);\n        maxPrice = Math.max(maxPrice, product.price);\n        totalPrice += product.price;\n      });\n\n      // 计算平均价格\n      const avgPrice =\n        productCount > 0 ? (totalPrice / productCount).toFixed(2) : 0;\n\n      return {\n        name: category.name,\n        productCount,\n        priceRange: {\n          min: productCount > 0 ? minPrice : 0,\n          max: maxPrice,\n          avg: avgPrice,\n        },\n      };\n    });\n  } catch (e) {\n    return [];\n  }\n};\n\n// 默认导出\nexport default {\n  getProductData,\n  updateProduct,\n  addProduct,\n  deleteProduct,\n  addCategory,\n  deleteCategory,\n  searchProducts,\n  advancedSearchProducts,\n  getHotProducts,\n  getRecommendedProducts,\n  initProductData,\n  getProductsWithPagination,\n  getCategoriesStats,\n};\n"],"names":["fetchCategories","fetchProductsByCategory","getDefaultProductData"],"mappings":";;;;AAMA,MAAM,0BAA0B,YAAY;AAC1C,MAAI;AAEF,UAAM,aAAa,MAAMA,sBAAAA;AAGzB,UAAM,SAAS,MAAM,QAAQ;AAAA,MAC3B,WAAW,IAAI,OAAO,aAAa;AAEjC,cAAM,WAAW,MAAMC,qBAAAA,wBAAwB,SAAS,EAAE;AAG1D,eAAO;AAAA,UACL,MAAM,SAAS;AAAA,UACf,UAAU,SAAS,IAAI,CAAC,YAAY;AAElC,mBAAO;AAAA,cACL,IAAI,QAAQ;AAAA,cACZ,OAAO,QAAQ,YAAY;AAAA,cAC3B,UACE,QAAQ,YAAY;AAAA;AAAA,cACtB,MAAM,QAAQ,QAAQ;AAAA,cACtB,MAAM,QAAQ,eAAe;AAAA;AAAA,cAC7B,aAAa,QAAQ,eAAe;AAAA,cACpC,OAAO,QAAQ,SAAS;AAAA,cACxB,UAAU,SAAS;AAAA;AAAA,cAEnB,GAAG;AAAA,YACjB;AAAA,UACA,CAAW;AAAA,QACX;AAAA,MACA,CAAO;AAAA,IACP;AAEI,WAAO;AAAA,EACR,SAAQ,OAAO;AACd,UAAM;AAAA,EACP;AACH;AAGY,MAAC,iBAAiB,YAAY;AACxC,MAAI;AAEF,UAAM,UAAU,MAAM;AACtB,WAAO;AAAA,EACR,SAAQ,GAAG;AAEV,WAAOC,qBAAqB,sBAAA;AAAA,EAC7B;AACH;AAGO,MAAM,qBAAqB,YAAY;AAC5C,MAAI;AAEF,UAAM,UAAU,MAAM;AACtB,WAAO;AAAA,EACR,SAAQ,GAAG;AAEV,WAAOA,qBAAqB,sBAAA;AAAA,EAC7B;AACH;AAwTY,MAAC,kBAAkB,YAAY;AACzC,MAAI;AACF,WAAO,MAAM,mBAAkB;AAAA,EAChC,SAAQ,GAAG;AACV,WAAOA,qBAAqB,sBAAA;AAAA,EAC7B;AACH;;;"}