{"version":3,"file":"productData.js","sources":["utils/productData.js"],"sourcesContent":["// 产品数据管理\nimport { fetchCategories, fetchCategoryById } from './api/categoryApi';\nimport { fetchProductsByCategory } from './api/productApi';\nimport { getDefaultProductData } from './productService';\n\n// 存储键名\nconst STORAGE_KEY = 'milk_tea_products';\nconst STORAGE_TIMESTAMP_KEY = 'milk_tea_products_timestamp';\nconst STORAGE_VERSION_KEY = 'milk_tea_products_version';\nconst DATA_CACHE_TIME = 60 * 60 * 1000; // 缓存有效期，默认1小时\nconst CURRENT_DATA_VERSION = '1.0'; // 数据结构版本号，当修改数据结构时更新此值\n\n// 从API获取产品和分类数据\nconst fetchProductDataFromAPI = async () => {\n    try {\n        // 1. 获取所有分类\n        const categories = await fetchCategories();\n        console.log('获取到的分类信息:', categories);\n        \n        // 2. 对每个分类获取对应的产品\n        const result = await Promise.all(\n            categories.map(async (category) => {\n                // 获取该分类下的产品\n                const products = await fetchProductsByCategory(category.id);\n                console.log(`分类${category.name}的产品:`, products);\n                \n                // 转换为前端需要的格式，确保字段映射正确\n                return {\n                    name: category.name,\n                    products: products.map(product => {\n                        // 统一字段名称，确保兼容性\n                        return {\n                            id: product.id,\n                            image: product.imageUrl || `/static/images/default-product.png`,\n                            imageUrl: product.imageUrl || `/static/images/default-product.png`, // 同时保留两个字段\n                            name: product.name || '',\n                            desc: product.description || '', // 确保desc和description都有值\n                            description: product.description || '',\n                            price: product.price || 0,\n                            category: category.name,\n                            // 保留其他可能的原始字段\n                            ...product\n                        };\n                    })\n                };\n            })\n        );\n        \n        // 打印转换后的产品数据结构用于调试\n        console.log('转换后的产品数据结构:', JSON.stringify(result[0]?.products[0] || {}));\n        \n        return result;\n    } catch (error) {\n        console.error('从API获取产品数据失败:', error);\n        throw error;\n    }\n}\n\n// 保存产品数据到本地存储\nexport const saveProductData = (data) => {\n    try {\n        // 保存数据、时间戳和版本号\n        uni.setStorageSync(STORAGE_KEY, JSON.stringify(data));\n        uni.setStorageSync(STORAGE_TIMESTAMP_KEY, Date.now());\n        uni.setStorageSync(STORAGE_VERSION_KEY, CURRENT_DATA_VERSION);\n        console.log('产品数据保存成功');\n        return true;\n    } catch (e) {\n        console.error('保存产品数据失败：', e);\n        return false;\n    }\n}\n\n// 从本地存储获取产品数据\nconst getProductDataFromStorage = () => {\n    try {\n        const storageData = uni.getStorageSync(STORAGE_KEY);\n        const timestamp = uni.getStorageSync(STORAGE_TIMESTAMP_KEY) || 0;\n        const version = uni.getStorageSync(STORAGE_VERSION_KEY) || '';\n        const now = Date.now();\n        \n        // 检查数据是否存在、未过期且版本匹配\n        if (storageData && \n            (now - timestamp < DATA_CACHE_TIME) && \n            version === CURRENT_DATA_VERSION) {\n            return JSON.parse(storageData);\n        }\n        \n        // 如果版本不匹配，清除旧数据\n        if (version !== CURRENT_DATA_VERSION) {\n            console.log(`数据版本不匹配(本地:${version}, 当前:${CURRENT_DATA_VERSION})，清除旧数据`);\n            clearProductDataCache();\n        }\n        \n        return null;\n    } catch (e) {\n        console.error('从本地存储获取产品数据失败：', e);\n        return null;\n    }\n}\n\n// 清除产品数据缓存\nexport const clearProductDataCache = () => {\n    try {\n        uni.removeStorageSync(STORAGE_KEY);\n        uni.removeStorageSync(STORAGE_TIMESTAMP_KEY);\n        uni.removeStorageSync(STORAGE_VERSION_KEY);\n        console.log('产品数据缓存已清除');\n        return true;\n    } catch (e) {\n        console.error('清除产品数据缓存失败：', e);\n        return false;\n    }\n}\n\n// 获取产品数据缓存信息\nexport const getProductDataCacheInfo = () => {\n    try {\n        const timestamp = uni.getStorageSync(STORAGE_TIMESTAMP_KEY) || 0;\n        const version = uni.getStorageSync(STORAGE_VERSION_KEY) || '';\n        const now = Date.now();\n        \n        // 如果缓存存在\n        if (timestamp > 0) {\n            const cacheAge = now - timestamp;\n            const expiresIn = Math.max(0, DATA_CACHE_TIME - cacheAge);\n            const isExpired = cacheAge >= DATA_CACHE_TIME;\n            const isOutdated = version !== CURRENT_DATA_VERSION;\n            \n            return {\n                exists: true,\n                timestamp,\n                formattedTime: new Date(timestamp).toLocaleString(),\n                age: cacheAge,\n                expiresIn,\n                isExpired,\n                version,\n                isOutdated,\n                currentVersion: CURRENT_DATA_VERSION\n            };\n        }\n        \n        // 无缓存\n        return {\n            exists: false,\n            currentVersion: CURRENT_DATA_VERSION\n        };\n    } catch (e) {\n        console.error('获取产品数据缓存信息失败：', e);\n        return {\n            exists: false,\n            error: e.message,\n            currentVersion: CURRENT_DATA_VERSION\n        };\n    }\n}\n\n// 获取产品数据 - 先尝试从API获取，如果失败则从本地存储获取，如果还是没有则使用默认数据\nexport const getProductData = async () => {\n    try {\n        // 先尝试从缓存获取\n        const cachedData = getProductDataFromStorage();\n        if (cachedData) {\n            console.log('从本地存储获取产品数据成功');\n            return cachedData;\n        }\n        \n        // 缓存不存在或已过期，从API获取\n        console.log('开始从API获取产品数据...');\n        const apiData = await fetchProductDataFromAPI();\n        \n        // 保存到本地存储\n        saveProductData(apiData);\n        console.log('从API获取产品数据成功并保存到本地');\n        \n        return apiData;\n    } catch (e) {\n        console.error('获取产品数据失败，使用默认数据：', e);\n        // 如果API和本地存储都失败，返回默认数据\n        return getDefaultProductData();\n    }\n}\n\n// 重置产品数据为默认数据\nexport const resetProductData = () => {\n    return saveProductData(getDefaultProductData());\n}\n\n// 刷新产品数据（强制从API获取）\nexport const refreshProductData = async () => {\n    try {\n        // 从API获取\n        const apiData = await fetchProductDataFromAPI();\n        \n        // 保存到本地存储\n        saveProductData(apiData);\n        console.log('产品数据刷新成功');\n        \n        return apiData;\n    } catch (e) {\n        console.error('刷新产品数据失败：', e);\n        // 如果API获取失败，尝试从本地获取\n        const localData = getProductDataFromStorage();\n        return localData || getDefaultProductData();\n    }\n}\n\n// 更新特定产品信息\nexport const updateProduct = async (categoryIndex, productIndex, updatedProduct) => {\n    try {\n        const allProducts = await getProductData();\n        \n        // 确保索引有效\n        if (categoryIndex >= 0 && \n            categoryIndex < allProducts.length && \n            productIndex >= 0 && \n            productIndex < allProducts[categoryIndex].products.length) {\n            \n            // 更新产品\n            allProducts[categoryIndex].products[productIndex] = {\n                ...allProducts[categoryIndex].products[productIndex],\n                ...updatedProduct\n            };\n            \n            // 保存更新后的数据\n            return saveProductData(allProducts);\n        }\n        return false;\n    } catch (e) {\n        console.error('更新产品失败：', e);\n        return false;\n    }\n}\n\n// 添加新产品到指定分类\nexport const addProduct = async (categoryIndex, newProduct) => {\n    try {\n        const allProducts = await getProductData();\n        \n        // 确保分类索引有效\n        if (categoryIndex >= 0 && categoryIndex < allProducts.length) {\n            // 添加新产品\n            allProducts[categoryIndex].products.push(newProduct);\n            \n            // 保存更新后的数据\n            return saveProductData(allProducts);\n        }\n        return false;\n    } catch (e) {\n        console.error('添加产品失败：', e);\n        return false;\n    }\n}\n\n// 删除产品\nexport const deleteProduct = async (categoryIndex, productIndex) => {\n    try {\n        const allProducts = await getProductData();\n        \n        // 确保索引有效\n        if (categoryIndex >= 0 && \n            categoryIndex < allProducts.length && \n            productIndex >= 0 && \n            productIndex < allProducts[categoryIndex].products.length) {\n            \n            // 删除产品\n            allProducts[categoryIndex].products.splice(productIndex, 1);\n            \n            // 保存更新后的数据\n            return saveProductData(allProducts);\n        }\n        return false;\n    } catch (e) {\n        console.error('删除产品失败：', e);\n        return false;\n    }\n}\n\n// 添加新分类\nexport const addCategory = async (newCategory) => {\n    try {\n        const allProducts = await getProductData();\n        \n        // 添加新分类\n        allProducts.push({\n            name: newCategory.name,\n            products: newCategory.products || []\n        });\n        \n        // 保存更新后的数据\n        return saveProductData(allProducts);\n    } catch (e) {\n        console.error('添加分类失败：', e);\n        return false;\n    }\n}\n\n// 删除分类\nexport const deleteCategory = async (categoryIndex) => {\n    try {\n        const allProducts = await getProductData();\n        \n        // 确保索引有效\n        if (categoryIndex >= 0 && categoryIndex < allProducts.length) {\n            // 删除分类\n            allProducts.splice(categoryIndex, 1);\n            \n            // 保存更新后的数据\n            return saveProductData(allProducts);\n        }\n        return false;\n    } catch (e) {\n        console.error('删除分类失败：', e);\n        return false;\n    }\n}\n\n// 搜索产品\nexport const searchProducts = async (keyword) => {\n    try {\n        if (!keyword) return [];\n        \n        const allProducts = await getProductData();\n        const result = [];\n        \n        // 转换关键词为小写以进行不区分大小写的搜索\n        const lowerKeyword = keyword.toLowerCase();\n        \n        // 遍历所有分类和产品\n        allProducts.forEach(category => {\n            category.products.forEach(product => {\n                // 检查产品名称或描述是否包含关键词\n                const nameMatch = product.name && product.name.toLowerCase().includes(lowerKeyword);\n                \n                // 检查description字段(后端API)或desc字段(本地数据)\n                const descMatch = \n                    (product.description && product.description.toLowerCase().includes(lowerKeyword)) || \n                    (product.desc && product.desc.toLowerCase().includes(lowerKeyword));\n                \n                if (nameMatch || descMatch) {\n                    result.push({\n                        ...product,\n                        category: category.name\n                    });\n                }\n            });\n        });\n        \n        // 打印匹配的结果和关键词用于调试\n        console.log(`搜索\"${keyword}\"找到${result.length}个结果:`);\n        result.forEach((item, index) => {\n            console.log(`结果${index + 1}: ${item.name}, 描述: ${item.description || item.desc || '无'}`);\n        });\n        \n        return result;\n    } catch (e) {\n        console.error('搜索产品失败：', e);\n        return [];\n    }\n}\n\n// 高级搜索产品\nexport const advancedSearchProducts = async (options = {}) => {\n    try {\n        const {\n            keyword = '',\n            minPrice = 0,\n            maxPrice = Infinity,\n            categoryNames = [],\n            sortBy = 'price', // 'price', 'name'\n            sortOrder = 'asc', // 'asc', 'desc'\n            limit = 0 // 限制返回结果数量，0表示不限制\n        } = options;\n        \n        // 获取所有产品数据\n        const allProducts = await getProductData();\n        let result = [];\n        \n        // 转换关键词为小写以进行不区分大小写的搜索\n        const lowerKeyword = keyword.toLowerCase();\n        \n        // 遍历所有分类和产品\n        allProducts.forEach(category => {\n            // 检查是否需要按分类筛选\n            if (categoryNames.length > 0 && !categoryNames.includes(category.name)) {\n                return; // 跳过不在指定分类中的产品\n            }\n            \n            category.products.forEach(product => {\n                // 关键词过滤 - 检查产品名称或描述是否包含关键词\n                const matchesKeyword = !keyword || \n                    product.name.toLowerCase().includes(lowerKeyword) ||\n                    product.desc.toLowerCase().includes(lowerKeyword);\n                \n                // 价格范围过滤\n                const matchesPrice = \n                    product.price >= minPrice && \n                    product.price <= maxPrice;\n                \n                // 如果满足所有筛选条件，添加到结果中\n                if (matchesKeyword && matchesPrice) {\n                    result.push({\n                        ...product,\n                        category: category.name\n                    });\n                }\n            });\n        });\n        \n        // 根据指定字段排序\n        result.sort((a, b) => {\n            if (sortBy === 'name') {\n                return sortOrder === 'asc' \n                    ? a.name.localeCompare(b.name)\n                    : b.name.localeCompare(a.name);\n            } else if (sortBy === 'price') {\n                return sortOrder === 'asc' \n                    ? a.price - b.price\n                    : b.price - a.price;\n            }\n            return 0;\n        });\n        \n        // 限制结果数量\n        if (limit > 0 && result.length > limit) {\n            result = result.slice(0, limit);\n        }\n        \n        return result;\n    } catch (e) {\n        console.error('高级搜索产品失败：', e);\n        return [];\n    }\n}\n\n// 获取热门产品（根据固定规则或推荐算法）\nexport const getHotProducts = async (limit = 6) => {\n    try {\n        // 在真实应用中，这里可能会调用专门的API获取热门产品\n        // 这里使用简单的模拟实现，取价格较高的前几个产品作为\"热门\"\n        const allProducts = await getProductData();\n        const hotProducts = [];\n        \n        // 收集所有产品\n        allProducts.forEach(category => {\n            category.products.forEach(product => {\n                hotProducts.push({\n                    ...product,\n                    category: category.name\n                });\n            });\n        });\n        \n        // 按价格降序排序并限制数量\n        return hotProducts\n            .sort((a, b) => b.price - a.price)\n            .slice(0, limit);\n    } catch (e) {\n        console.error('获取热门产品失败：', e);\n        return [];\n    }\n}\n\n// 获取推荐产品（基于分类）\nexport const getRecommendedProducts = async (categoryName, limit = 4) => {\n    try {\n        const allProducts = await getProductData();\n        const recommendedProducts = [];\n        \n        // 查找指定分类\n        const targetCategory = allProducts.find(category => \n            category.name === categoryName\n        );\n        \n        if (targetCategory && targetCategory.products.length > 0) {\n            // 从目标分类中随机选择几个产品\n            const shuffled = [...targetCategory.products].sort(() => 0.5 - Math.random());\n            const selected = shuffled.slice(0, Math.min(limit, shuffled.length));\n            \n            selected.forEach(product => {\n                recommendedProducts.push({\n                    ...product,\n                    category: categoryName\n                });\n            });\n        }\n        \n        // 如果推荐产品不足，从其他分类中补充\n        if (recommendedProducts.length < limit) {\n            const neededProducts = limit - recommendedProducts.length;\n            const otherProducts = [];\n            \n            allProducts.forEach(category => {\n                if (category.name !== categoryName) {\n                    category.products.forEach(product => {\n                        otherProducts.push({\n                            ...product,\n                            category: category.name\n                        });\n                    });\n                }\n            });\n            \n            // 随机打乱并选择所需数量的产品\n            const shuffled = otherProducts.sort(() => 0.5 - Math.random());\n            const selected = shuffled.slice(0, Math.min(neededProducts, shuffled.length));\n            \n            recommendedProducts.push(...selected);\n        }\n        \n        return recommendedProducts;\n    } catch (e) {\n        console.error('获取推荐产品失败：', e);\n        return [];\n    }\n}\n\n// 初始化产品数据 - 用于应用启动时\nexport const initProductData = async () => {\n    try {\n        // 检查是否需要刷新数据\n        const timestamp = uni.getStorageSync(STORAGE_TIMESTAMP_KEY) || 0;\n        const now = Date.now();\n        \n        // 如果数据过期或不存在，则从API获取\n        if (now - timestamp >= DATA_CACHE_TIME || !uni.getStorageSync(STORAGE_KEY)) {\n            console.log('产品数据需要刷新');\n            return await refreshProductData();\n        } else {\n            console.log('使用本地缓存的产品数据');\n            return getProductDataFromStorage();\n        }\n    } catch (e) {\n        console.error('初始化产品数据失败：', e);\n        return getDefaultProductData();\n    }\n}\n\n/**\n * 获取单个分类下的产品\n * @param {Number} categoryId 分类ID\n * @returns {Promise<Object>} 包含分类和产品的对象\n */\nexport const getCategoryProducts = async (categoryId) => {\n  try {\n    // 1. 获取分类信息\n    const category = await fetchCategoryById(categoryId);\n    if (!category) {\n      throw new Error('分类不存在');\n    }\n    \n    // 2. 获取该分类下的产品\n    const products = await fetchProductsByCategory(categoryId);\n    \n    // 3. 转换为前端需要的格式\n    return {\n      name: category.name,\n      products: products.map(product => ({\n        id: product.id,\n        image: product.imageUrl || `/static/images/default-product.png`,\n        name: product.name,\n        desc: product.description,\n        price: product.price\n      }))\n    };\n  } catch (error) {\n    console.error(`获取分类${categoryId}的产品失败:`, error);\n    throw error;\n  }\n};\n\n/**\n * 分页获取产品\n * @param {Object} options 分页选项\n * @returns {Promise<Object>} 分页结果\n */\nexport const getProductsWithPagination = async (options = {}) => {\n    try {\n        const {\n            page = 1,\n            pageSize = 10,\n            keyword = '',\n            categoryName = '',\n            minPrice = 0,\n            maxPrice = Infinity,\n            sortBy = 'price',\n            sortOrder = 'asc'\n        } = options;\n        \n        // 获取所有满足筛选条件的产品\n        const filterOptions = {\n            keyword,\n            minPrice,\n            maxPrice,\n            categoryNames: categoryName ? [categoryName] : [],\n            sortBy,\n            sortOrder\n        };\n        \n        // 使用高级搜索获取所有符合条件的产品\n        const allFilteredProducts = await advancedSearchProducts(filterOptions);\n        \n        // 计算总数和总页数\n        const total = allFilteredProducts.length;\n        const totalPages = Math.ceil(total / pageSize);\n        \n        // 计算当前页的数据\n        const startIndex = (page - 1) * pageSize;\n        const endIndex = Math.min(startIndex + pageSize, total);\n        const currentPageData = allFilteredProducts.slice(startIndex, endIndex);\n        \n        return {\n            data: currentPageData,\n            pagination: {\n                total,\n                page,\n                pageSize,\n                totalPages,\n                hasNextPage: page < totalPages,\n                hasPreviousPage: page > 1\n            }\n        };\n    } catch (e) {\n        console.error('分页获取产品失败：', e);\n        return {\n            data: [],\n            pagination: {\n                total: 0,\n                page: options.page || 1,\n                pageSize: options.pageSize || 10,\n                totalPages: 0,\n                hasNextPage: false,\n                hasPreviousPage: false\n            },\n            error: e.message\n        };\n    }\n};\n\n/**\n * 获取各分类产品数量\n * @returns {Promise<Array>} 分类统计数据\n */\nexport const getCategoriesStats = async () => {\n    try {\n        const allProducts = await getProductData();\n        \n        // 计算每个分类的产品数量和最大/最小价格\n        return allProducts.map(category => {\n            const productCount = category.products.length;\n            \n            // 计算价格范围\n            let minPrice = Infinity;\n            let maxPrice = 0;\n            let totalPrice = 0;\n            \n            category.products.forEach(product => {\n                minPrice = Math.min(minPrice, product.price);\n                maxPrice = Math.max(maxPrice, product.price);\n                totalPrice += product.price;\n            });\n            \n            // 计算平均价格\n            const avgPrice = productCount > 0 ? \n                (totalPrice / productCount).toFixed(2) : 0;\n            \n            return {\n                name: category.name,\n                productCount,\n                priceRange: {\n                    min: productCount > 0 ? minPrice : 0,\n                    max: maxPrice,\n                    avg: avgPrice\n                }\n            };\n        });\n    } catch (e) {\n        console.error('获取分类统计数据失败：', e);\n        return [];\n    }\n};\n\n// 默认导出\nexport default {\n    getProductData,\n    saveProductData,\n    resetProductData,\n    updateProduct,\n    addProduct,\n    deleteProduct,\n    addCategory,\n    deleteCategory,\n    searchProducts,\n    advancedSearchProducts,\n    getHotProducts,\n    getRecommendedProducts,\n    initProductData,\n    clearProductDataCache,\n    getProductDataCacheInfo,\n    getProductsWithPagination,\n    getCategoriesStats\n} "],"names":["fetchCategories","uni","fetchProductsByCategory","getDefaultProductData"],"mappings":";;;;;AAMA,MAAM,cAAc;AACpB,MAAM,wBAAwB;AAC9B,MAAM,sBAAsB;AAC5B,MAAM,kBAAkB,KAAK,KAAK;AAClC,MAAM,uBAAuB;AAG7B,MAAM,0BAA0B,YAAY;;AACxC,MAAI;AAEA,UAAM,aAAa,MAAMA,sBAAAA;AACzBC,kBAAY,MAAA,MAAA,OAAA,8BAAA,aAAa,UAAU;AAGnC,UAAM,SAAS,MAAM,QAAQ;AAAA,MACzB,WAAW,IAAI,OAAO,aAAa;AAE/B,cAAM,WAAW,MAAMC,qBAAAA,wBAAwB,SAAS,EAAE;AAC1DD,sBAAAA,MAAA,MAAA,OAAA,8BAAY,KAAK,SAAS,IAAI,QAAQ,QAAQ;AAG9C,eAAO;AAAA,UACH,MAAM,SAAS;AAAA,UACf,UAAU,SAAS,IAAI,aAAW;AAE9B,mBAAO;AAAA,cACH,IAAI,QAAQ;AAAA,cACZ,OAAO,QAAQ,YAAY;AAAA,cAC3B,UAAU,QAAQ,YAAY;AAAA;AAAA,cAC9B,MAAM,QAAQ,QAAQ;AAAA,cACtB,MAAM,QAAQ,eAAe;AAAA;AAAA,cAC7B,aAAa,QAAQ,eAAe;AAAA,cACpC,OAAO,QAAQ,SAAS;AAAA,cACxB,UAAU,SAAS;AAAA;AAAA,cAEnB,GAAG;AAAA,YAC/B;AAAA,UACA,CAAqB;AAAA,QACrB;AAAA,MACA,CAAa;AAAA,IACb;AAGQA,kBAAAA,MAAY,MAAA,OAAA,8BAAA,eAAe,KAAK,YAAU,YAAO,CAAC,MAAR,mBAAW,SAAS,OAAM,CAAA,CAAE,CAAC;AAEvE,WAAO;AAAA,EACV,SAAQ,OAAO;AACZA,kBAAA,MAAA,MAAA,SAAA,8BAAc,iBAAiB,KAAK;AACpC,UAAM;AAAA,EACT;AACL;AAGO,MAAM,kBAAkB,CAAC,SAAS;AACrC,MAAI;AAEAA,kBAAG,MAAC,eAAe,aAAa,KAAK,UAAU,IAAI,CAAC;AACpDA,kBAAAA,MAAI,eAAe,uBAAuB,KAAK,IAAK,CAAA;AACpDA,kBAAAA,MAAI,eAAe,qBAAqB,oBAAoB;AAC5DA,kBAAAA,MAAY,MAAA,OAAA,8BAAA,UAAU;AACtB,WAAO;AAAA,EACV,SAAQ,GAAG;AACRA,kBAAc,MAAA,MAAA,SAAA,8BAAA,aAAa,CAAC;AAC5B,WAAO;AAAA,EACV;AACL;AAGA,MAAM,4BAA4B,MAAM;AACpC,MAAI;AACA,UAAM,cAAcA,cAAAA,MAAI,eAAe,WAAW;AAClD,UAAM,YAAYA,cAAG,MAAC,eAAe,qBAAqB,KAAK;AAC/D,UAAM,UAAUA,cAAG,MAAC,eAAe,mBAAmB,KAAK;AAC3D,UAAM,MAAM,KAAK;AAGjB,QAAI,eACC,MAAM,YAAY,mBACnB,YAAY,sBAAsB;AAClC,aAAO,KAAK,MAAM,WAAW;AAAA,IAChC;AAGD,QAAI,YAAY,sBAAsB;AAClCA,oBAAAA,MAAY,MAAA,OAAA,8BAAA,cAAc,OAAO,QAAQ,oBAAoB,SAAS;AACtE;IACH;AAED,WAAO;AAAA,EACV,SAAQ,GAAG;AACRA,kBAAA,MAAA,MAAA,SAAA,8BAAc,kBAAkB,CAAC;AACjC,WAAO;AAAA,EACV;AACL;AAGO,MAAM,wBAAwB,MAAM;AACvC,MAAI;AACAA,wBAAI,kBAAkB,WAAW;AACjCA,wBAAI,kBAAkB,qBAAqB;AAC3CA,wBAAI,kBAAkB,mBAAmB;AACzCA,kBAAAA,kDAAY,WAAW;AACvB,WAAO;AAAA,EACV,SAAQ,GAAG;AACRA,kBAAA,MAAA,MAAA,SAAA,+BAAc,eAAe,CAAC;AAC9B,WAAO;AAAA,EACV;AACL;AA6CY,MAAC,iBAAiB,YAAY;AACtC,MAAI;AAEA,UAAM,aAAa;AACnB,QAAI,YAAY;AACZA,oBAAAA,MAAA,MAAA,OAAA,+BAAY,eAAe;AAC3B,aAAO;AAAA,IACV;AAGDA,kBAAAA,MAAY,MAAA,OAAA,+BAAA,iBAAiB;AAC7B,UAAM,UAAU,MAAM;AAGtB,oBAAgB,OAAO;AACvBA,kBAAAA,MAAA,MAAA,OAAA,+BAAY,oBAAoB;AAEhC,WAAO;AAAA,EACV,SAAQ,GAAG;AACRA,kBAAA,MAAA,MAAA,SAAA,+BAAc,oBAAoB,CAAC;AAEnC,WAAOE,qBAAqB,sBAAA;AAAA,EAC/B;AACL;AAQO,MAAM,qBAAqB,YAAY;AAC1C,MAAI;AAEA,UAAM,UAAU,MAAM;AAGtB,oBAAgB,OAAO;AACvBF,kBAAAA,MAAY,MAAA,OAAA,+BAAA,UAAU;AAEtB,WAAO;AAAA,EACV,SAAQ,GAAG;AACRA,kBAAc,MAAA,MAAA,SAAA,+BAAA,aAAa,CAAC;AAE5B,UAAM,YAAY;AAClB,WAAO,aAAaE,qBAAAA;EACvB;AACL;AAyTY,MAAC,kBAAkB,YAAY;AACvC,MAAI;AAEA,UAAM,YAAYF,cAAG,MAAC,eAAe,qBAAqB,KAAK;AAC/D,UAAM,MAAM,KAAK;AAGjB,QAAI,MAAM,aAAa,mBAAmB,CAACA,cAAAA,MAAI,eAAe,WAAW,GAAG;AACxEA,oBAAAA,kDAAY,UAAU;AACtB,aAAO,MAAM,mBAAkB;AAAA,IAC3C,OAAe;AACHA,oBAAAA,MAAY,MAAA,OAAA,+BAAA,aAAa;AACzB,aAAO,0BAAyB;AAAA,IACnC;AAAA,EACJ,SAAQ,GAAG;AACRA,kBAAA,MAAA,MAAA,SAAA,+BAAc,cAAc,CAAC;AAC7B,WAAOE,qBAAqB,sBAAA;AAAA,EAC/B;AACL;;;"}